<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>SRFI 32: Sort Libraries</title>
  <meta name="viewport" content=
  "width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/srfi.css" type="text/css">
  <link href="/favicon.png" rel="icon" sizes="192x192" type=
  "image/png">
</head>
<body>
  <h1>Title</h1>
  <p>Sort Libraries</p>
  <h1>Author</h1>
  <p>Olin Shivers</p>
  <h1>Status</h1>
  <p>This SRFI is currently in <em>withdrawn</em> status. Here is
  <a href="https://srfi.schemers.org/srfi-process.html">an
  explanation</a> of each status that a SRFI can hold. To provide
  input on this SRFI, please send email to <code><a href=
  "mailto:srfi+minus+32+at+srfi+dotschemers+dot+org">srfi-32@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.
  To subscribe to the list, follow <a href=
  "https://srfi.schemers.org/srfi-list-subscribe.html">these
  instructions</a>. You can access previous messages via the
  mailing list <a href=
  "https://srfi-email.schemers.org/srfi-32">archive</a>.</p>
  <ul>
    <li>Received: 2002/07/12</li>
    <li>Draft: 2002/07/15-2003/10/15</li>
    <li>Draft extension: 2003/01/31</li>
    <li>Withdrawn: 2003/07/17</li>
  </ul>
  <h1>Abstract</h1>
  <p>Current Scheme sorting packages are, every one of them,
  surprisingly bad. I've designed the API for a full-featured sort
  toolkit, which I propose as an SRFI. The spec comes with 1200
  lines of high-quality reference code: tightly written, highly
  commented, portable code, available for free. Implementors want
  this code. It's better than what you have.</p>
  <h1>Table of contents</h1>
  <ul>
    <li>Abstract</li>
    <li>Procedure index</li>
    <li>Introduction</li>
    <li>What's wrong with the current state of affairs?</li>
    <li>Design rules
      <ul>
        <li>What vs. how</li>
        <li>Consistency across function signatures</li>
        <li>Data parameter first, less-than parameter after</li>
        <li>Ordering, comparison functions & stability</li>
        <li>All vector operations accept optional subrange
        parameters</li>
        <li>Required vs. allowed side-effects</li>
      </ul>
    </li>
    <li>Procedure specification
      <ul>
        <li>Procedure naming and functionality</li>
        <li>Types of parameters and return values</li>
        <li>sort-lib - general sorting package</li>
        <li>Algorithm-specific sorting packages</li>
      </ul>
    </li>
    <li>Algorithmic properties</li>
    <li>Topics to be resolved during discussion phase</li>
    <li>Porting and optimisation</li>
    <li>References & Links</li>
    <li>Acknowledgements</li>
    <li>Copyright</li>
  </ul>
  <h1>Procedure index</h1>
  <pre>
list-sorted?                    vector-sorted?

list-merge                      vector-merge
list-sort                       vector-sort
list-stable-sort                vector-stable-sort
list-delete-neighbor-dups       vector-delete-neighbor-dups

list-merge!                     vector-merge!
list-sort!                      vector-sort!
list-stable-sort!               vector-stable-sort!
list-delete-neighbor-dups!      vector-delete-neighbor-dups!

heap-sort   quick-sort   insert-sort   list-merge-sort   vector-merge-sort
heap-sort!  quick-sort!  insert-sort!  list-merge-sort!  vector-merge-sort!
  </pre>
  <h1>Introduction</h1>
  <p>As I'll detail bewlow, I wasn't very happy with the state of
  the Scheme world for sorting and merging lists and vectors. So I
  have designed and written a fairly comprehensive sorting &
  merging toolkit. It is</p>
  <ul>
    <li>very portable,</li>
    <li>much better code than what is currently in Elk, Gambit,
    Bigloo, Scheme-&gt;C, MzScheme, RScheme, Scheme48, MIT Scheme,
    or slib, and</li>
    <li>priced to move: free code.</li>
  </ul>
  <p>The package includes</p>
  <ul>
    <li>Vector insert sort (stable)</li>
    <li>Vector heap sort</li>
    <li>Vector quick sort (with median-of-3 pivot picking)</li>
    <li>Vector merge sort (stable)</li>
    <li>Pure and destructive list merge sort (stable)</li>
    <li>Stable vector and list merge</li>
    <li>Miscellaneous sort-related procedures: Vector and list
    merging, sorted? predicates, vector binary search, vector and
    list delete-equal-neighbor procedures.</li>
    <li>A general, non-algorithmic set of procedure names for
    general sorting and merging.</li>
  </ul>
  <p>Scheme programmers may want to adopt this package. I'd like
  Scheme implementors to adopt this code and its API -- in fact,
  the code is a bribe to make it easy for implementors to converge
  on the suggested API. I mean, you'd really have to be a boor to
  take this free code I wrote and mutate its interface over to your
  incompatible, unportable API, wouldn't you? But you could, of
  course -- it's freely available. More in the spirit of the
  offering, you could make this API available, and then also write
  a little module providing your old interface that is defined in
  terms of this API. "Scheme implementors," in this context,
  includes slib, which isn't really a standalone implementation of
  Scheme, but is an influential collection of API's and code.</p>
  <p>The code is tightly bummed. It is clearly written, and
  commented in my usual voluminous style. This includes notes on
  porting and implementation-specific optimisations.</p>
  <h1>What's wrong with the current state of affairs?</h1>
  <p>It's just amazing to me that in 2002, sorting and merging
  hasn't been completely put to bed. These are well-understood
  algorithms, each of them well under a page of code. The
  straightforward algorithms are basic, core stuff --
  sophomore-level. But if you tour the major Scheme implementations
  out there on the Net, you find badly written code that provides
  extremely spotty coverage of the algorithm space. One
  implementation even has a buggy implementation that has been in
  use for about 20 years!</p>
  <p>Open source-code is a wonderful thing. In a couple of hours, I
  was able to download and check the sources of 9 Scheme systems.
  Here are my notes from the systems I checked. You can skip to the
  next section if you aren't morbidly curious.</p>
  <h2>slib</h2>
  <pre>
  sorted? vector-or-list &lt;
  merge  list1 list2 &lt;
  merge! list1 list2 &lt;
  sort  vector-or-list &lt;
  sort! vector-or-list &lt;
                         </pre>
  <p>Richard O'Keefe's stable list merge sort is right idea, but
  implemented using gratuitous variable side effects. It also does
  redundant SET-CDR!s. The vector sort converts to list, merge
  sorts, then reconverts to vector. This is a bad idea -- non-local
  pointer chasing bad; vector shuffling good.</p>
  <h2>MIT Scheme</h2>
  <pre>
  sort!       vector &lt;
  merge-sort! vector &lt;
  quick-sort! vector &lt;

  sort       vector-or-list &lt;
  merge-sort vector-or-list &lt;
  quick-sort vector-or-list &lt;
                              </pre>
  <p>Naive vector quicksort: loser, for worst-case performance
  reasons. List sort by "list-&gt;vector; quicksort;
  vector-&gt;list," hence also loser. A clever stable vector merge
  sort, albeit not very bummed.</p>
  <h2>Scheme 48 & T</h2>
  <pre>
  sort-list  list &lt;
  sort-list! list &lt;
  list-merge! list1 list2 &lt;
                            </pre>
  <p>Bob Nix's implementation of online merge-sort, written in the
  early 80's. Conses unnecessary bookkeeping structure, which isn't
  necessary with a proper recursive formulation. Also, does
  redundant SET-CDR!s. No vector sort. Also, has a bug -- is
  claimed to be a stable sort, but isn't! To see this, get the S48
  code, and try</p>
  <pre>
    (define (my&lt; x y) (&lt; (quotient x 2) (quotient y 2)))
    (list-merge! (list 0 2) (list   3) my&lt;)             ; -&gt; (0 2 3)
                         (list-merge! (list   2) (list 0 3) my&lt;)                ; -&gt; (0 3 2)
                         </pre>
  <p>This could be fixed very easily, but it isn't worth it given
  the other problems with the algorithm.</p>
  <h2>RScheme</h2>
  <pre>
  vector-sort! vector &lt;
  sort collection &lt;
</pre>
  <p>Good basic implementation of vector heapsort, which has O(n lg
  n) worst-case time. Code ugly, needs tuning. List sort by
  "list-&gt;vector; sort; vector-&gt;list", which allocates
  unneeded temp storage. Nothing for stable sorting.</p>
  <h2>MzScheme</h2>
  <p>Naive quicksort -- but not available for vector sorting, even
  though it internally uses a vector. Nothing for stable sorting,
  and naive quicksort has bad worst-case behaviour.</p>
  <h2>Bigloo, Scheme-&gt;C</h2>
  <p>Couldn't find anything -- but maybe I didn't search for the
  right thing, since the Bigloo names are French. (I invite
  correction from the Bigloo implementors.)</p>
  <h2>Gambit</h2>
  <pre>
  sort-list list &lt;
</pre>
  <p>Nothing for vectors. Simple, slow, unstable merge sort for
  lists.</p>
  <h2>Elk</h2>
  <p>Another naive quicksort. Lists handled by converting to
  vector.</p>
  <pre>
  sort  vector-or-list &lt;
  sort! vector-or-list &lt;
</pre>
  <h2>Chez Scheme</h2>
  <pre>
  merge  &lt; list1 list2
  merge! &lt; list1 list2
  sort  &lt; list
  sort! &lt; list
</pre>
  <p>These are stable. I have not seen the source code.</p>
  <h2>Common Lisp</h2>
  <pre>
  sort        sequence &lt; [key]
  stable-sort sequence &lt; [key]
  merge result-type sequence1 sequence2 &lt; [key]
</pre>
  <p>The sort procedures are allowed, but not required, to be
  destructive.</p>
  <h2>SML/NJ</h2>
  <pre>
  sort: ('a*'a -&gt; bool) -&gt; 'a list -&gt; 'a list
</pre>
  <p>"Smooth applicative merge sort," which is stable. There is
  also a highly bummed quicksort for vectors.</p>
  <p>The right solution: Implement a full toolbox of carefully
  written standard sort routines.</p>
  <p>Having the source available for all of these above-cited
  Schemes made life a lot easier writing this code. I appreciate
  the authors making their source available under such open
  terms.</p>
  <h1>Design rules</h1>
  <h2>What vs. how</h2>
  <p>There are two different interfaces: "what" (simple) & "how"
  (detailed).</p>
  <ul>
    <li>
      <p>Simple: you specify semantics: datatype (list or vector),
      mutability, and stability.</p>
    </li>
    <li>
      <p>Detailed: you specify the actual algorithm (quick, heap,
      insert, merge). Different algorithms have different
      properties, both semantic & pragmatic, so these exports are
      necessary.</p>
      <p>It is necessarily the case that the specifications of
      these procedures make statements about execution
      "pragmatics." For example, the sole distinction between heap
      sort and quick sort -- both of which are provided by this
      library -- is one of execution time, which is not a
      "semantic" distinction. Similar resource-use statements are
      made about "iterative" procedures, meaning that they can
      execute on input of arbitrary size without needing to
      allocate an unbounded number of stack frames.</p>
    </li>
  </ul>
  <h2>Consistency across function signatures</h2>
  <p>The two interfaces share common function signatures wherever
  possible, to facilitate switching a given call from one procedure
  to another.</p>
  <h2>Data parameter first, less-than parameter after</h2>
  <p>These procedures uniformly observe the following parameter
  order: the data to be sorted come before the the comparison
  function. That is, we write <code>(sort lis &lt;)</code> not
  <code>(sort &lt; lis)</code>. This is consistent with every
  single implementation out there, with the sole exception of Chez
  Scheme.</p>
  <p>In my opinion, it would be more consistent with other Scheme
  libraries to put the ordering function first -- the "operation
  currying" convention. (E.g., consider FOR-EACH or MAP or FIND.) I
  decided to leave things as they are in favor of near-total
  backwards compatibility with existing practice.</p>
  <p>[Perhaps this should be discussed.]</p>
  <h2>Ordering, comparison functions & stability</h2>
  <p>These routines take a &lt; comparison function, not a &lt;=
  comparison function, and they sort into increasing order. The
  difference between a &lt; spec and a &lt;= spec comes up in two
  places:</p>
  <ul>
    <li>the definition of an ordered or sorted data set, and</li>
    <li>the definition of a stable sorting algorithm.</li>
  </ul>
  <ul>
    <li>
      <p>We say that a data set (a list or vector) is *sorted* or
      *ordered* if it contains no adjacent pair of values ... X Y
      ... such that Y &lt; X.</p>
      <p>In other words, scanning across the data never takes a
      "downwards" step.</p>
      <p>If you use a &lt;= procedure where these algorithms expect
      a &lt; procedure, you may not get the answers you expect. For
      example, the LIST-SORTED? function will return false if you
      pass it a &lt;= comparison function and an ordered list
      containing adjacent equal elements.</p>
    </li>
    <li>
      <p>A "stable" sort is one that preserves the pre-existing
      order of equal elements. Suppose, for example, that we sort a
      list of numbers by comparing their absolute values, i.e.,
      using comparison function <code>(lambda (x y) (&lt; (abs x)
      (abs y)))</code> If we sort a list that contains both 3 and
      -3: <code>... 3 ... -3 ...</code> then a stable sort is an
      algorithm that will not swap the order of these two elements,
      that is, the answer will look like <code>... 3 -3 ...</code>
      not <code>... -3 3 ...</code></p>
      <p>Choosing &lt; for the comparison function instead of &lt;=
      affects how stability is coded. Given an adjacent pair X Y,
      (&lt; y x) means "Y should be moved in front of X" --
      otherwise, leave things as they are. So using a &lt;=
      function where a &lt; function is expected will *invert*
      stability.</p>
      <p>This is due to the definition of equality, given a &lt;
      comparator:</p>
      <pre>(and (not (&lt; x y)) (not (&lt; y x)))
      </pre>
      <p>The definition is rather different, given a &lt;=
      comparator:</p>
      <pre> (and (&lt;= x y) (&lt;= x y))</pre>
    </li>
    <li>
      <p>A "stable" merge is one that reliably favors one of its
      data sets when equal items appear in both data sets. *All
      merge operations in this library are stable*, breaking ties
      between data sets in favor of the first data set -- elements
      of the first list come before equal elements in the second
      list.</p>
      <p>So, if we are merging two lists of numbers ordered by
      absolute value using the stable merge operation
      LIST-MERGE</p>
      <pre>
    (list-merge '(0 -2 4 8 -10) '(-1 3 -4 7)
                (lambda (x y) (&lt; (abs x) (abs y))))
                                 </pre>
      <p>reliably places the 4 of the first list before the
      equal-comparing -4 of the second list:</p>
      <pre>(0 -1 -2 4 -4 7 8 -10)</pre>
    </li>
  </ul>
  <p>In short, if your comparison function F answers true to (F x
  x), then using a stable sorting or merging algorithm will not
  give you a stable sort or merge, and LIST-SORTED? may surprise
  you. Note that you can synthesize a &lt; function from a &lt;=
  function with <code>(lambda (x y) (not (&lt;= y x)))</code> if
  need be.</p>
  <p>Precise definitions give sharp edges to tools, but require
  care in use. "Measure twice, cut once."</p>
  <p>I have adopted the choice of &lt; from Common Lisp. I assume
  they had a good reason for adopting &lt; instead of &lt;=. I'd
  love to know what this reason is; send me email if you can
  explain it, please.</p>
  <h2>All vector operations accept optional subrange
  parameters</h2>
  <p>The vector operations specified below all take optional
  START/END arguments indicating a selected subrange of a vector's
  elements. If a START parameter or START/END parameter pair is
  given to such a procedure, they must be exact, non-negative
  integers, such that <code>0 &lt;= START &lt;= END &lt;=
  (VECTOR-LENGTH V)</code> where V is the related vector parameter.
  If not specified, they default to 0 and the length of the vector,
  respectively. They are interpreted to select the range
  [START,END), that is, all elements from index START (inclusive)
  up to, but not including, index END.</p>
  <h2>Required vs. allowed side-effects</h2>
  <p>LIST-SORT! and LIST-STABLE-SORT! are allowed, but not
  required, to alter their arguments' cons cells to construct the
  result list. This is consistent with the what-not-how character
  of the group of procedures to which they belong (the "sort-lib"
  package).</p>
  <p>The LIST-DELETE-NEIGHBOR-DUPS!, LIST-MERGE! and
  LIST-MERGE-SORT! procedures, on the other hand, provide specific
  algorithms, and, as such, explicitly commit to the use of
  side-effects on their input lists in order to guarantee their key
  algorithmic properties (e.g., linear-time operation,
  constant-space stack use).</p>
  <address>
    Editor: Francisco Solsona
  </address>
</body>
</html>
